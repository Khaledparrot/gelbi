<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Secret Chat</title>
  <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/libsodium-wrappers@0.7.9"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
    body { background: #f5f7fa; color: #333; padding: 16px; max-width: 500px; margin: 0 auto; height: 100vh; display: flex; flex-direction: column; }
    .screen { display: none; flex: 1; flex-direction: column; }
    .active { display: flex !important; }
    h1 { text-align: center; margin: 16px 0; color: #2c3e50; font-size: 24px; }
    input, button { width: 100%; padding: 12px; margin: 8px 0; border: 1px solid #ddd; border-radius: 8px; font-size: 16px; }
    button { background: #3498db; color: white; border: none; cursor: pointer; font-weight: bold; }
    button:hover { background: #2980b9; }
    .btn-secondary { background: #95a5a6; }
    .btn-danger { background: #e74c3c; }
    .contact-item { 
      background: white; 
      padding: 12px; 
      margin: 8px 0; 
      border-radius: 8px; 
      display: flex; 
      justify-content: space-between; 
      align-items: center;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    .status { 
      font-size: 12px; 
      padding: 4px 8px; 
      border-radius: 12px; 
      color: white;
    }
    .online { background: #2ecc71; }
    .offline { background: #95a5a6; }
    .actions button { 
      padding: 4px 8px; 
      font-size: 12px; 
      margin-left: 4px;
    }
    #videoContainer { display: none; }
    #chatArea { 
      flex: 1; 
      background: white; 
      padding: 12px; 
      margin: 12px 0; 
      border-radius: 8px; 
      overflow-y: auto; 
      display: none;
    }
    .message { 
      padding: 8px 0; 
      word-wrap: break-word; 
    }
    .you { color: #3498db; }
    .peer { color: #2ecc71; }
    #qrReader { width: 100%; height: 300px; background: #000; display: none; }
    video { width: 100%; height: 100%; object-fit: cover; }
    .header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; }
    .back-btn { background: none; border: none; font-size: 18px; color: #3498db; }
  </style>
</head>
<body>
  <!-- Password Screen -->
  <div id="passwordScreen" class="screen active">
    <h1>🔒 Secret Chat</h1>
    <input type="password" id="passwordInput" placeholder="Enter password" autocomplete="off">
    <button onclick="setPassword()">Enter</button>
    <p style="text-align: center; margin-top: 20px; color: #7f8c8d; font-size: 14px;">
      Your password encrypts all contact data. No recovery if forgotten!
    </p>
  </div>

  <!-- Main Screen -->
  <div id="mainScreen" class="screen">
    <div class="header">
      <h1>Secret Chat</h1>
      <button class="btn-secondary" onclick="showQrGenerator()">+ New</button>
    </div>
    
    <div id="contactsList">
      <!-- Contacts loaded here -->
    </div>
    
    <div id="noContacts" style="text-align: center; padding: 20px; color: #7f8c8d;">
      <p>No contacts yet</p>
      <button class="btn-secondary" onclick="showQrGenerator()" style="margin-top: 10px;">Add Contact</button>
    </div>
  </div>

  <!-- QR Generator -->
  <div id="qrGeneratorScreen" class="screen">
    <div class="header">
      <button class="back-btn" onclick="showMainScreen()">&larr;</button>
      <h1>My QR Code</h1>
    </div>
    <div id="myQr" style="text-align: center; padding: 20px;"></div>
    <p style="text-align: center; margin: 10px 0; color: #7f8c8d;">
      Share this QR with your friend
    </p>
  </div>

  <!-- QR Scanner -->
  <div id="qrScannerScreen" class="screen">
    <div class="header">
      <button class="back-btn" onclick="showMainScreen()">&larr;</button>
      <h1>Scan QR</h1>
    </div>
    <div id="qrReader"></div>
    <button class="btn-secondary" onclick="startScanner()" style="margin-top: 10px;">Start Camera</button>
  </div>

  <!-- Chat Screen -->
  <div id="chatScreen" class="screen">
    <div class="header">
      <button class="back-btn" onclick="closeChat()">&larr;</button>
      <h1 id="chatTitle">Chat</h1>
      <div id="chatStatus" class="status offline">Offline</div>
    </div>
    <div id="chatArea"></div>
    <input type="text" id="messageInput" placeholder="Type a message..." disabled>
    <button onclick="sendMessage()" disabled>Send</button>
  </div>

  <script>
    // Global state
    let MASTER_PASSWORD = null;
    let CURRENT_CONTACT = null;
    let PEER_CONNECTION = null;
    let DATA_CHANNEL = null;
    let CONTACTS = [];
    
    // TURN server (replace with your own for production)
    const TURN_SERVER = {
      urls: "turn:freeturn.net:3478",
      username: "free",
      credential: "free"
    };

    // Initialize
    document.addEventListener('DOMContentLoaded', () => {
      loadContacts();
    });

    // Password handling
    async function setPassword() {
      const pwd = document.getElementById('passwordInput').value;
      if (!pwd) return alert('Please enter a password');
      
      MASTER_PASSWORD = pwd;
      document.getElementById('passwordInput').value = '';
      showMainScreen();
    }

    // Screen navigation
    function showMainScreen() {
      document.getElementById('mainScreen').classList.add('active');
      document.getElementById('qrGeneratorScreen').classList.remove('active');
      document.getElementById('qrScannerScreen').classList.remove('active');
      document.getElementById('chatScreen').classList.remove('active');
      renderContacts();
    }

    function showQrGenerator() {
      generateMyQr();
      document.getElementById('mainScreen').classList.remove('active');
      document.getElementById('qrGeneratorScreen').classList.add('active');
    }

    function showQrScanner() {
      document.getElementById('mainScreen').classList.remove('active');
      document.getElementById('qrScannerScreen').classList.add('active');
      startScanner();
    }

    // QR Code Handling
    async function generateMyQr() {
      await libsodium.ready;
      const keyPair = libsodium.crypto_kx_keypair();
      window.MY_KEYPAIR = keyPair;
      
      // Create offer
      const pc = new RTCPeerConnection({ iceServers: [TURN_SERVER] });
      pc.createDataChannel('secret-chat');
      
      pc.onicecandidate = async (e) => {
        if (e.candidate) return;
        const offer = pc.localDescription;
        const qrData = JSON.stringify({
          type: 'offer',
          sdp: offer.sdp,
          publicKey: libsodium.to_base64(keyPair.publicKey)
        });
        
        document.getElementById('myQr').innerHTML = '';
        new QRCode(document.getElementById('myQr'), qrData);
        pc.close();
      };
      
      await pc.createOffer();
      await pc.setLocalDescription(pc.localDescription);
    }

    // QR Scanner
    let video, canvas, ctx;
    async function startScanner() {
      const qrReader = document.getElementById('qrReader');
      qrReader.innerHTML = '<video playsinline></video>';
      video = qrReader.querySelector('video');
      canvas = document.createElement('canvas');
      ctx = canvas.getContext('2d');
      
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } });
        video.srcObject = stream;
        video.play();
        requestAnimationFrame(tick);
      } catch (err) {
        alert('Camera access denied: ' + err.message);
      }
    }

    function tick() {
      if (video.readyState === video.HAVE_ENOUGH_DATA) {
        canvas.height = video.videoHeight;
        canvas.width = video.videoWidth;
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const code = jsQR(imageData.data, imageData.width, imageData.height, {
          inversionAttempts: "dontInvert",
        });
        
        if (code) {
          try {
            const data = JSON.parse(code.data);
            if (data.type === 'offer') {
              saveContact(data);
              showMainScreen();
              video.srcObject.getTracks().forEach(track => track.stop());
              return;
            }
          } catch (e) {
            console.error('QR parse error', e);
          }
        }
      }
      requestAnimationFrame(tick);
    }

    // Contact Management
    async function saveContact(offerData) {
      if (!MASTER_PASSWORD) return;
      
      await libsodium.ready;
      const encrypted = encryptData(JSON.stringify(offerData), MASTER_PASSWORD);
      
      const contact = {
        id: Date.now().toString(),
        name: 'Contact ' + (CONTACTS.length + 1),
        data: encrypted,
        timestamp: new Date().toISOString()
      };
      
      CONTACTS.push(contact);
      saveContactsToStorage();
      alert('Contact added!');
    }

    function renderContacts() {
      const list = document.getElementById('contactsList');
      const noContacts = document.getElementById('noContacts');
      
      if (CONTACTS.length === 0) {
        noContacts.style.display = 'block';
        list.innerHTML = '';
      } else {
        noContacts.style.display = 'none';
        list.innerHTML = CONTACTS.map(contact => `
          <div class="contact-item">
            <div>
              <div>${contact.name}</div>
              <div style="font-size:12px;color:#7f8c8d;">${new Date(contact.timestamp).toLocaleString()}</div>
            </div>
            <div class="actions">
              <span class="status offline">Offline</span>
              <button onclick="startChat('${contact.id}')">Chat</button>
              <button class="btn-danger" onclick="deleteContact('${contact.id}')">✕</button>
            </div>
          </div>
        `).join('');
      }
    }

    function deleteContact(id) {
      if (confirm('Delete this contact?')) {
        CONTACTS = CONTACTS.filter(c => c.id !== id);
        saveContactsToStorage();
        renderContacts();
      }
    }

    // Storage (encrypted)
    function saveContactsToStorage() {
      if (!MASTER_PASSWORD) return;
      
      const encrypted = encryptData(JSON.stringify(CONTACTS), MASTER_PASSWORD);
      localStorage.setItem('secure_chat_contacts', encrypted);
    }

    function loadContacts() {
      const encrypted = localStorage.getItem('secure_chat_contacts');
      if (!encrypted || !MASTER_PASSWORD) return;
      
      try {
        const decrypted = decryptData(encrypted, MASTER_PASSWORD);
        CONTACTS = JSON.parse(decrypted);
      } catch (e) {
        console.error('Decrypt failed', e);
        alert('Invalid password or corrupted data');
        CONTACTS = [];
      }
    }

    // Encryption helpers
    async function encryptData(data, password) {
      await libsodium.ready;
      const key = libsodium.crypto_pwhash(
        32,
        new TextEncoder().encode(password),
        libsodium.randombytes_buf(libsodium.crypto_pwhash_SALTBYTES),
        3, // ops limit
        33554432, // mem limit (32MB)
        libsodium.crypto_pwhash_ALG_ARGON2ID13
      );
      
      const nonce = libsodium.randombytes_buf(libsodium.crypto_secretbox_NONCEBYTES);
      const encrypted = libsodium.crypto_secretbox_easy(
        new TextEncoder().encode(data),
        nonce,
        key
      );
      
      return libsodium.to_base64(new Uint8Array([...nonce, ...encrypted]));
    }

    async function decryptData(encryptedData, password) {
      await libsodium.ready;
      const combined = libsodium.from_base64(encryptedData);
      const nonce = combined.slice(0, libsodium.crypto_secretbox_NONCEBYTES);
      const ciphertext = combined.slice(libsodium.crypto_secretbox_NONCEBYTES);
      
      // Derive key (same as encrypt)
      const salt = combined.slice(0, libsodium.crypto_pwhash_SALTBYTES); // Reuse first 16 bytes as salt
      const key = libsodium.crypto_pwhash(
        32,
        new TextEncoder().encode(password),
        salt,
        3,
        33554432,
        libsodium.crypto_pwhash_ALG_ARGON2ID13
      );
      
      const decrypted = libsodium.crypto_secretbox_open_easy(ciphertext, nonce, key);
      return new TextDecoder().decode(decrypted);
    }

    // Chat functionality
    async function startChat(contactId) {
      const contact = CONTACTS.find(c => c.id === contactId);
      if (!contact) return;
      
      CURRENT_CONTACT = contact;
      document.getElementById('chatTitle').innerText = contact.name;
      document.getElementById('mainScreen').classList.remove('active');
      document.getElementById('chatScreen').classList.add('active');
      
      // Decrypt contact data
      try {
        const decrypted = decryptData(contact.data, MASTER_PASSWORD);
        const offerData = JSON.parse(decrypted);
        connectToPeer(offerData);
      } catch (e) {
        alert('Failed to decrypt contact data');
        closeChat();
      }
    }

    async function connectToPeer(offerData) {
      await libsodium.ready;
      const keyPair = libsodium.crypto_kx_keypair();
      window.MY_KEYPAIR = keyPair;
      
      PEER_CONNECTION = new RTCPeerConnection({ 
        iceServers: [TURN_SERVER],
        iceTransportPolicy: "relay" // Hide IPs!
      });
      
      PEER_CONNECTION.ondatachannel = (e) => {
        DATA_CHANNEL = e.channel;
        setupDataChannel();
      };
      
      const offer = new RTCSessionDescription(offerData);
      await PEER_CONNECTION.setRemoteDescription(offer);
      
      const answer = await PEER_CONNECTION.createAnswer();
      await PEER_CONNECTION.setLocalDescription(answer);
      
      // Send answer back (in real app, you'd exchange this too)
      // For simplicity, we assume direct connection after offer
      updateStatus('Connecting...');
    }
    
    function setupDataChannel() {
      DATA_CHANNEL.onopen = () => {
        updateStatus('Online', 'online');
        document.getElementById('messageInput').disabled = false;
        document.getElementById('messageInput').focus();
        document.querySelector('#chatScreen button').disabled = false;
      };
      
      DATA_CHANNEL.onmessage = (e) => {
        if (!MASTER_PASSWORD || !CURRENT_CONTACT) return;
        
        try {
          const msg = JSON.parse(e.data);
          const nonce = libsodium.from_base64(msg.nonce);
          const encrypted = libsodium.from_base64(msg.payload);
          
          // Derive key from password + peer's public key
          const decrypted = decryptMessage(encrypted, nonce);
          addMessage('peer', decrypted);
        } catch (ex) {
          console.error('Decrypt failed', ex);
          addMessage('peer', '❌ Decryption failed');
        }
      };
      
      DATA_CHANNEL.onclose = () => {
        updateStatus('Offline', 'offline');
      };
    }
    
    async function decryptMessage(encrypted, nonce) {
      // In real app, you'd store peer's public key
      // For demo, we'll assume it's in CURRENT_CONTACT
      // (You'd need to modify saveContact to store it properly)
      return "Decrypted message"; // Simplified
    }
    
    function sendMessage() {
      const input = document.getElementById('messageInput');
      const msg = input.value.trim();
      if (!msg || !DATA_CHANNEL) return;
      
      input.value = '';
      addMessage('you', msg);
      
      // In real app: encrypt with peer's public key
      const encryptedMsg = JSON.stringify({
        nonce: 'base64',
        payload: 'base64'
      });
      
      if (DATA_CHANNEL && DATA_CHANNEL.readyState === 'open') {
        DATA_CHANNEL.send(encryptedMsg);
      }
    }
    
    function addMessage(sender, text) {
      const chatArea = document.getElementById('chatArea');
      chatArea.style.display = 'block';
      const div = document.createElement('div');
      div.className = `message ${sender}`;
      div.innerText = text;
      chatArea.appendChild(div);
      chatArea.scrollTop = chatArea.scrollHeight;
    }
    
    function updateStatus(text, className = 'offline') {
      const status = document.getElementById('chatStatus');
      status.innerText = text;
      status.className = `status ${className}`;
    }
    
    function closeChat() {
      if (PEER_CONNECTION) {
        PEER_CONNECTION.close();
        PEER_CONNECTION = null;
      }
      DATA_CHANNEL = null;
      CURRENT_CONTACT = null;
      document.getElementById('chatArea').innerHTML = '';
      document.getElementById('chatArea').style.display = 'none';
      showMainScreen();
    }
  </script>
</body>
</html>
