<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Minimal Secure P2P</title>

<!-- QR and QR scanning libs -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
<script src="https://unpkg.com/jsqr/dist/jsQR.js"></script>

<style>
  /* Minimal centered layout */
  html,body{height:100%;margin:0;font-family:Arial,Helvetica,sans-serif}
  .wrap{min-height:100%;display:flex;align-items:center;justify-content:center;padding:16px}
  .card{width:100%;max-width:520px;border:1px solid #ddd;padding:16px;border-radius:8px;box-shadow:0 4px 12px rgba(0,0,0,.06)}
  .row{margin:8px 0;display:flex;gap:8px;align-items:center}
  input,textarea,button{font-size:15px;padding:8px;border:1px solid #bbb;border-radius:6px;width:100%}
  textarea{height:100px;resize:vertical}
  button{cursor:pointer}
  .small{width:auto;padding:8px 12px}
  .hidden{display:none}
  .center{text-align:center}
  .contacts-list{max-height:180px;overflow:auto;border:1px solid #eee;padding:8px;border-radius:6px}
  .contact-item{padding:6px;border-bottom:1px dashed #eee;display:flex;justify-content:space-between;align-items:center}
  .status{font-size:13px;color:#666}
  video{width:100%;border-radius:6px;background:#000}
  .qr-box{display:flex;justify-content:center;gap:12px;flex-wrap:wrap}
</style>
</head>
<body>
  <div class="wrap">
    <div class="card" id="app">
      <!-- Password screen -->
      <div id="pwScreen">
        <h3 class="center">Enter your password</h3>
        <div class="row"><input id="pwInput" type="password" placeholder="Password"></div>
        <div class="row"><button id="pwBtn">Continue</button></div>
        <p class="status">Contacts stored locally are encrypted with this password.</p>
      </div>

      <!-- Method selection -->
      <div id="methodScreen" class="hidden">
        <h3 class="center">Choose connection method</h3>
        <div class="row"><button id="methodCopy" class="small">Copy / Paste</button><button id="methodQr" class="small">Use QR codes</button></div>
        <div class="row"><button id="goContacts" class="small">Back to Contacts</button></div>
      </div>

      <!-- Copy/paste UI -->
      <div id="copyScreen" class="hidden">
        <h3 class="center">Copy & Paste connection</h3>
        <div class="row"><button id="genOfferBtn">Generate my connection (offer)</button></div>
        <div class="row"><textarea id="offerArea" placeholder="Your offer will appear here"></textarea></div>
        <div class="row"><p class="center">Peer's answer (paste here):</p></div>
        <div class="row"><textarea id="answerIn" placeholder="Paste peer answer here"></textarea></div>
        <div class="row"><button id="acceptAnswerBtn">Accept peer answer</button></div>
        <div class="row"><button id="copyBackBtn" class="small">Back</button></div>
        <p class="status">After handshake completes the contact will be saved (encrypted).</p>
      </div>

      <!-- QR generation/show one-by-one -->
      <div id="qrGenScreen" class="hidden">
        <h3 class="center">Show your 4 QR codes (one by one)</h3>
        <div id="qrGenBox" class="qr-box"></div>
        <div class="row"><button id="qrNextBtn" class="small">Next</button><button id="qrBackBtn" class="small">Back</button></div>
        <p class="status">Show codes to peer in order (1 → 4).</p>
      </div>

      <!-- QR scan flow -->
      <div id="qrScanScreen" class="hidden">
        <h3 class="center">Scan 4 QR codes in order</h3>
        <div id="videoWrap"><video id="scanVideo" playsinline autoplay></video></div>
        <div class="row"><button id="qrScanStart" class="small">Start Camera</button><button id="qrScanStop" class="small">Stop</button></div>
        <div class="row"><p id="scanProgress" class="status">Scanned <span id="scannedCount">0</span>/4</p></div>
        <div class="row"><button id="qrScanBack" class="small">Back</button></div>
      </div>

      <!-- Contacts list -->
      <div id="contactsScreen" class="hidden">
        <h3 class="center">Contacts</h3>
        <div class="contacts-list" id="contactsList"></div>
        <div class="row"><button id="addNewBtn">Add new (choose method)</button><button id="logoutBtn" class="small">Logout (clear password)</button></div>
      </div>

      <!-- Chat -->
      <div id="chatScreen" class="hidden">
        <h3 id="chatTitle" class="center">Chat</h3>
        <div id="chatHistory" style="border:1px solid #eee;padding:8px;border-radius:6px;height:200px;overflow:auto"></div>
        <div class="row"><input id="chatInput" placeholder="Message..."><button id="chatSend" class="small">Send</button></div>
        <div class="row"><button id="chatClose" class="small">Close Chat</button></div>
        <p id="connStatus" class="status">Connection status: <span id="connLabel">—</span></p>
      </div>

    </div>
  </div>

<script>
/* ========= Globals and storage keys ========= */
const CONTACTS_KEY = 'secure_p2p_contacts_v1'; // encrypted contacts blob in localStorage
let PASSWORD = null;                // stored only in sessionStorage (on success)
let CONTACTS = [];                  // decrypted array of contacts [{id,name,data...}]
let CURRENT_PEER = null;            // contact object when chatting
let pc = null, dc = null;           // RTCPeerConnection & DataChannel
let videoStream = null;
let qrParts = [], qrIndex = 0, generatedParts = [];
let scanParts = [];

/* ========= Crypto helpers using WebCrypto AES-GCM & PBKDF2 ========= */
async function deriveKey(pw, saltBytes){
  // PBKDF2 derive AES-GCM key
  const enc = new TextEncoder();
  const pwKey = await crypto.subtle.importKey('raw', enc.encode(pw), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    { name:'PBKDF2', salt: saltBytes, iterations: 120000, hash:'SHA-256' },
    pwKey,
    { name:'AES-GCM', length:256 },
    false,
    ['encrypt','decrypt']
  );
}
async function encryptWithPassword(plaintext, pw){
  const enc = new TextEncoder();
  const salt = crypto.getRandomValues(new Uint8Array(16));
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const key = await deriveKey(pw, salt);
  const ct = await crypto.subtle.encrypt({name:'AES-GCM', iv}, key, enc.encode(plaintext));
  // store salt, iv, ct as base64 JSON
  return btoa(JSON.stringify({ salt:Array.from(salt), iv:Array.from(iv), ct:Array.from(new Uint8Array(ct)) }));
}
async function decryptWithPassword(payloadB64, pw){
  const obj = JSON.parse(atob(payloadB64));
  const salt = new Uint8Array(obj.salt);
  const iv = new Uint8Array(obj.iv);
  const ct = new Uint8Array(obj.ct);
  const key = await deriveKey(pw, salt);
  const pt = await crypto.subtle.decrypt({name:'AES-GCM', iv}, key, ct);
  return new TextDecoder().decode(pt);
}

/* ========= UI helpers ========= */
function show(id){ document.getElementById('pwScreen').classList.add('hidden'); hideAll(); document.getElementById(id).classList.remove('hidden'); }
function hideAll(){
  ['methodScreen','copyScreen','qrGenScreen','qrScanScreen','contactsScreen','chatScreen'].forEach(i=>document.getElementById(i).classList.add('hidden'));
}
function alertSafe(msg){ try{ alert(msg); }catch(e){ console.log(msg); } }

/* ========= Password flow ========= */
document.getElementById('pwBtn').addEventListener('click', async ()=>{
  const pw = document.getElementById('pwInput').value.trim();
  if(!pw){ alertSafe('Please enter a password'); return; }

  // if contacts exist, try to decrypt them
  const stored = localStorage.getItem(CONTACTS_KEY);
  if(stored){
    try{
      const dec = await decryptWithPassword(stored, pw);
      CONTACTS = JSON.parse(dec) || [];
      // store password in sessionStorage only
      sessionStorage.setItem('secure_pw', pw);
      PASSWORD = pw;
      showContacts();
      return;
    }catch(e){
      alertSafe('Password incorrect for stored contacts. If you forgot it, contacts cannot be recovered.');
      return;
    }
  }

  // no contacts found -> set session password and go to method selection
  sessionStorage.setItem('secure_pw', pw);
  PASSWORD = pw;
  show('methodScreen');
});

/* ========= Contacts UI ========= */
function showContacts(){
  show('contactsScreen');
  renderContacts();
}
function renderContacts(){
  const list = document.getElementById('contactsList');
  list.innerHTML = '';
  if(!CONTACTS || CONTACTS.length===0){ list.innerHTML = '<div class="center">No contacts saved</div>'; return; }
  CONTACTS.forEach((c, idx)=>{
    const div = document.createElement('div');
    div.className = 'contact-item';
    div.innerHTML = `<div><strong>${c.name||('Contact '+(idx+1))}</strong><div class="status">${new Date(c.ts).toLocaleString()}</div></div>
                     <div><button class="small" data-idx="${idx}">Chat</button> <button class="small" data-del="${idx}">Delete</button></div>`;
    list.appendChild(div);
  });
  // attach events
  list.querySelectorAll('button[data-idx]').forEach(b=>{
    b.addEventListener('click', async (ev)=>{
      const idx = +ev.target.dataset.idx;
      const c = CONTACTS[idx];
      // start connecting to this saved contact (it contains offer/answer or remote info)
      await startConnectionFromSaved(c);
    });
  });
  list.querySelectorAll('button[data-del]').forEach(b=>{
    b.addEventListener('click', async (ev)=>{
      const idx = +ev.target.dataset.del;
      if(!confirm('Delete contact?')) return;
      CONTACTS.splice(idx,1);
      await persistContacts();
      renderContacts();
    });
  });
}

/* persist contacts encrypted using PASSWORD */
async function persistContacts(){
  if(!PASSWORD) { alertSafe('No password in session'); return; }
  const json = JSON.stringify(CONTACTS);
  const blob = await encryptWithPassword(json, PASSWORD);
  localStorage.setItem(CONTACTS_KEY, blob);
}

/* ========= Method selection handlers ========= */
document.getElementById('methodCopy').addEventListener('click', ()=>{ hideAll(); document.getElementById('copyScreen').classList.remove('hidden'); });
document.getElementById('methodQr').addEventListener('click', ()=>{ hideAll(); document.getElementById('qrGenScreen').classList.remove('hidden'); });
document.getElementById('goContacts').addEventListener('click', ()=> showContacts());

/* back buttons */
document.getElementById('copyBackBtn').addEventListener('click', ()=> show('methodScreen'));
document.getElementById('qrBackBtn').addEventListener('click', ()=> show('methodScreen'));
document.getElementById('qrScanBack').addEventListener('click', ()=> show('methodScreen'));

/* add new contact button */
document.getElementById('addNewBtn').addEventListener('click', ()=> show('methodScreen'));

/* logout */
document.getElementById('logoutBtn').addEventListener('click', ()=>{
  sessionStorage.removeItem('secure_pw');
  PASSWORD = null;
  // go back to password screen
  document.getElementById('pwInput').value = '';
  show('pwScreen');
});

/* ========= WebRTC & connection helpers ========= */

/* create a local offer and data channel, return base64(offer) */
async function createLocalOffer(){
  pc = new RTCPeerConnection();
  dc = pc.createDataChannel('chat');
  setupDataChannel(dc);
  // gather all candidates automatically, but we will strip candidate lines to keep size small
  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);
  // Wait for ICE gathering complete (or small timeout)
  await waitForIceGathering(pc, 2500);
  let sdp = pc.localDescription.sdp || offer.sdp || '';
  // strip candidate lines to reduce QR length (works if relay/tURNS used)
  sdp = sdp.replace(/a=candidate:.*\r\n/g,'').replace(/.*\.local.*\r\n/g,'');
  return btoa(JSON.stringify({ type:'offer', sdp }));
}

/* After receiving remote answer, set it and perform handshake */
async function finishWithAnswer(answerRaw, contactMeta){
  try{
    const obj = JSON.parse(atob(answerRaw));
    if(!obj || !obj.sdp) throw new Error('Invalid answer format');
    await pc.setRemoteDescription({ type:'answer', sdp: obj.sdp });
  }catch(e){
    throw new Error('Failed to set remote description: ' + e.message);
  }
  // handshake check
  const ok = await performHandshakeCheck();
  if(!ok) throw new Error('Handshake failed');
  // persist contact info and go to chat
  await saveContact(contactMeta);
  openChat(contactMeta);
}

/* perform handshake: send ping with nonce, expect same nonce reply within 5s */
function performHandshakeCheck(){
  return new Promise((resolve)=>{
    if(!dc || dc.readyState !== 'open'){ return resolve(false); }
    const nonce = Math.floor(Math.random()*1e9).toString();
    let got = false;
    function onmsg(e){
      try{
        const obj = JSON.parse(e.data);
        if(obj && obj.type==='handshake' && obj.nonce===nonce && obj.reply===true){
          got=true;
          dc.removeEventListener('message', onmsg);
          resolve(true);
        }
      }catch(_){}
    }
    // listen for incoming handshake and reply accordingly
    dc.addEventListener('message', function incoming(e){
      try{
        const obj = JSON.parse(e.data);
        if(obj && obj.type==='handshake' && obj.nonce){
          // reply with same nonce & reply:true
          dc.send(JSON.stringify({type:'handshake', nonce:obj.nonce, reply:true}));
        }
      }catch(_){}
    });

    dc.addEventListener('message', onmsg);
    // send handshake
    dc.send(JSON.stringify({ type:'handshake', nonce, reply:false }));
    // timeout
    setTimeout(()=>{ if(!got) { try{ dc.removeEventListener('message', onmsg);}catch(_){} resolve(false);} },5000);
  });
}

/* helper: wait for ICE gatheringcomplete or timeout */
function waitForIceGathering(pcRef, timeoutMs=3000){
  return new Promise(resolve=>{
    if(pcRef.iceGatheringState === 'complete') return resolve();
    const id = setTimeout(()=>{ resolve(); }, timeoutMs);
    pcRef.addEventListener('icegatheringstatechange', ()=> {
      if(pcRef.iceGatheringState === 'complete'){ clearTimeout(id); resolve(); }
    });
  });
}

/* Data channel setup to handle messages (text only) */
function setupDataChannel(channel){
  channel.onopen = ()=> {
    console.log('DataChannel open');
    document.getElementById('connLabel').textContent = 'Open';
  };
  channel.onmessage = async (ev) => {
    try{
      const payload = JSON.parse(ev.data);
      // handshake messages handled elsewhere automatically
      if(payload && payload.type==='chat'){
        const dec = await decryptWithPassword(payload.msg, PASSWORD);
        appendChatMessage(dec, false);
      }
    }catch(e){
      console.log('msg parse error', e);
    }
  };
  channel.onclose = ()=> { document.getElementById('connLabel').textContent='Closed'; };
}

/* send chat message encrypted */
async function sendChatMessage(text){
  if(!dc || dc.readyState !== 'open') { alertSafe('Channel not open'); return; }
  const enc = await encryptWithPassword(text, PASSWORD);
  dc.send(JSON.stringify({ type:'chat', msg: enc }));
  appendChatMessage(text, true);
}

/* ========= Copy / Paste flow ========= */
document.getElementById('genOfferBtn').addEventListener('click', async ()=>{
  try{
    const offerB64 = await createLocalOffer();
    const parts = splitIntoN(offerB64, 4);
    document.getElementById('offerArea').value = offerB64; // full option for copy
    // also prepare QR parts for showing if needed
    generatedParts = parts;
    // show single-part view in qrGenScreen if user switches
    alertSafe('Offer generated. Share to peer (copy or QR).');
  }catch(e){
    alertSafe('Failed to create offer: '+ e.message);
  }
});

/* Accept answer (paste answer into input) */
document.getElementById('acceptAnswerBtn').addEventListener('click', async ()=>{
  const answerRaw = document.getElementById('answerIn').value.trim();
  if(!answerRaw){ alertSafe('Paste peer answer first'); return; }
  // finish with answer
  try{
    // contact meta minimal
    const meta = { id: Date.now().toString(), name: 'Contact '+(CONTACTS.length+1), ts:Date.now(), remote: answerRaw };
    await finishWithAnswer(answerRaw, meta);
    alertSafe('Connection established and contact saved.');
    showContacts();
  }catch(e){
    alertSafe('Failed to finish connection: '+e.message);
  }
});

/* ========= QR show / next logic (one-by-one) ========= */
document.getElementById('qrNextBtn').addEventListener('click', ()=>{
  if(!generatedParts || generatedParts.length===0) return;
  qrIndex = (qrIndex + 1) % generatedParts.length;
  drawGeneratedPart();
});
document.getElementById('qrBackBtn').addEventListener('click', ()=> show('methodScreen'));
function drawGeneratedPart(){
  const box = document.getElementById('qrGenBox');
  box.innerHTML = '';
  const div = document.createElement('div');
  new QRCode(div, { text: generatedParts[qrIndex], width: 200, height: 200 });
  box.appendChild(div);
}

/* generate full offer and split into 4, show first */
function prepareQrOfferAndShow(){
  createLocalOffer().then(b64=>{
    generatedParts = splitIntoN(b64, 4);
    qrIndex = 0;
    drawGeneratedPart();
  }).catch(e=>alertSafe('Failed: '+e.message));
}

/* ========= QR scanning flow (collect 4 parts in order) ========= */
document.getElementById('qrScanStart').addEventListener('click', ()=> startQrScan());
document.getElementById('qrScanStop').addEventListener('click', ()=> stopQrScan());
let scanAnimationId = null;

async function startQrScan(){
  scanParts = [];
  document.getElementById('scannedCount').textContent = '0';
  const v = document.getElementById('scanVideo');
  try{
    videoStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment', width: { ideal: 1280 } } });
    v.srcObject = videoStream;
    await v.play();
    document.getElementById('qrScanScreen').classList.remove('hidden');
    scanLoop();
  }catch(e){
    alertSafe('Camera not available: ' + e.message);
  }
}
function stopQrScan(){
  if(videoStream){ videoStream.getTracks().forEach(t=>t.stop()); videoStream=null; }
  const v = document.getElementById('scanVideo'); v.pause(); v.srcObject = null;
  if(scanAnimationId) cancelAnimationFrame(scanAnimationId);
}
function scanLoop(){
  const v = document.getElementById('scanVideo');
  if(!v || v.readyState < 2){ scanAnimationId = requestAnimationFrame(scanLoop); return; }
  const canvas = document.createElement('canvas');
  canvas.width = v.videoWidth;
  canvas.height = v.videoHeight;
  const ctx = canvas.getContext('2d');
  ctx.drawImage(v, 0, 0, canvas.width, canvas.height);
  const img = ctx.getImageData(0,0,canvas.width, canvas.height);
  const code = jsQR(img.data, img.width, img.height, { inversionAttempts: 'attemptBoth' });
  if(code && code.data){
    // only accept new and keep order
    if(scanParts.length === 0 || scanParts[scanParts.length-1] !== code.data){
      scanParts.push(code.data);
      document.getElementById('scannedCount').textContent = String(scanParts.length);
    }
    // when we have 4 parts, stop and assemble
    if(scanParts.length >= 4){
      stopQrScan();
      const assembled = scanParts.join('');
      processScannedOfferOrAnswer(assembled);
      return;
    }
  }
  scanAnimationId = requestAnimationFrame(scanLoop);
}

/* process assembled offer/answer */
async function processScannedOfferOrAnswer(b64){
  // if we don't have an existing pc, then we are the answering peer (we received offer)
  if(!pc){
    try{
      const obj = JSON.parse(atob(b64));
      if(!obj || !obj.sdp) throw new Error('Invalid offer');
      // create pc and set remote, then create answer and display as 4 QR codes for peer to scan back
      pc = new RTCPeerConnection();
      pc.ondatachannel = (ev)=>{ dc = ev.channel; setupDataChannel(dc); };
      await pc.setRemoteDescription({ type:'offer', sdp: obj.sdp });
      const ans = await pc.createAnswer();
      await pc.setLocalDescription(ans);
      await waitForIceGathering(pc, 2500);
      const sdp = (pc.localDescription && pc.localDescription.sdp) || ans.sdp;
      // remove candidates to keep small
      const sdpClean = sdp.replace(/a=candidate:.*\r\n/g,'').replace(/.*\\.local.*\\r\\n/g,'');
      const ansB64 = btoa(JSON.stringify({ type:'answer', sdp: sdpClean }));
      generatedParts = splitIntoN(ansB64, 4);
      qrIndex = 0;
      drawGeneratedPart();
      alertSafe('Answer generated — show your 4 QR codes to peer so they can scan them back.');
      // now wait for peer to set remote description (they will, after scanning)
      // After they set remote, handshake check will run on their side then our side via performHandshakeCheck()
    }catch(e){
      alertSafe('Failed processing offer: '+ e.message);
      pc=null;
    }
  } else {
    // we already had a pc & datachannel: this is likely the answer scanned by the original offerer
    try{
      const obj = JSON.parse(atob(b64));
      if(!obj || !obj.sdp) throw new Error('Invalid answer');
      await pc.setRemoteDescription({ type:'answer', sdp: obj.sdp });
      // handshake
      const ok = await performHandshakeCheck();
      if(!ok) { alertSafe('Handshake failed'); return; }
      // save contact with minimal meta
      const meta = { id: Date.now().toString(), name: 'Contact '+(CONTACTS.length+1), ts: Date.now(), remote: b64 };
      await saveContact(meta);
      openChat(meta);
      alertSafe('Connection established and saved.');
    }catch(e){
      alertSafe('Failed processing answer: '+ e.message);
    }
  }
}

/* ========= Utility: split into N pieces ========= */
function splitIntoN(str, n){
  const size = Math.ceil(str.length / n);
  const out = [];
  for(let i=0;i<n;i++) out.push(str.slice(i*size, (i+1)*size));
  return out;
}

/* ========= Save contact (encrypt data and persist) ========= */
async function saveContact(meta){
  // meta should include remote (base64 offer/answer) so we can reconnect later
  CONTACTS.push(meta);
  await persistContacts();
}

/* ========= Start connection to saved contact (reconnect) ========= */
async function startConnectionFromSaved(contact){
  // contact.remote contains base64 either offer or answer — we need to determine role
  PASSWORD = sessionStorage.getItem('secure_pw');
  if(!PASSWORD){ alertSafe('Session password missing. Please log in again.'); return show('pwScreen'); }
  try{
    const obj = JSON.parse(atob(contact.remote));
    // If it's an offer, we must create answer (we are responder) -> same as processing scanned offer
    // If it's answer, we are the offerer and must create new local offer? Simpler approach: treat saved remote as an offer; if it's an answer we may still try to setRemote (best effort)
    if(obj && obj.type === 'offer'){
      // simulate scanning an offer: call processScannedOfferOrAnswer with the base64 parts as if scanned
      pc = new RTCPeerConnection();
      pc.ondatachannel = (ev)=>{ dc = ev.channel; setupDataChannel(dc); };
      await pc.setRemoteDescription({ type:'offer', sdp: obj.sdp });
      const ans = await pc.createAnswer();
      await pc.setLocalDescription(ans);
      await waitForIceGathering(pc, 2500);
      const sdpClean = (pc.localDescription.sdp || ans.sdp).replace(/a=candidate:.*\r\n/g,'');
      const ansB64 = btoa(JSON.stringify({ type:'answer', sdp: sdpClean }));
      // show answer as 4 QR pieces for remote to scan (but since this is reconnecting we may instead expect they are online)
      generatedParts = splitIntoN(ansB64, 4);
      qrIndex = 0;
      drawGeneratedPart();
      show('qrGenScreen');
      alertSafe('Answer generated for this saved contact — have peer scan the QR codes.');
    } else if(obj && obj.type === 'answer'){
      // If we saved an answer (unusual), create a new offer instead
      const offerB64 = await createLocalOffer();
      generatedParts = splitIntoN(offerB64, 4);
      qrIndex = 0;
      drawGeneratedPart();
      show('qrGenScreen');
      alertSafe('Offer generated — show these to your peer.');
    } else {
      alertSafe('Saved contact data not understood.');
    }
  }catch(e){
    alertSafe('Failed to use saved contact: '+ e.message);
  }
}

/* ========= Chat UI and lifecycle ========= */
function openChat(meta){
  CURRENT_PEER = meta;
  show('chatScreen');
  document.getElementById('chatTitle').textContent = meta.name || 'Chat';
  document.getElementById('connLabel').textContent = 'Testing...';
  // load chat history from sessionStorage if any
  const histKey = 'chat_'+meta.id;
  const histRaw = sessionStorage.getItem(histKey);
  const history = histRaw ? JSON.parse(histRaw) : [];
  const container = document.getElementById('chatHistory');
  container.innerHTML = '';
  history.forEach(it => {
    const d = document.createElement('div'); d.textContent = (it.me ? 'Me: ' : 'Peer: ') + it.msg; container.appendChild(d);
  });
  // set send button
  document.getElementById('chatSend').onclick = async ()=>{
    const text = document.getElementById('chatInput').value.trim();
    if(!text) return;
    await sendChatMessage(text);
    saveChatMessage(meta.id, text, true);
    document.getElementById('chatInput').value = '';
  };
  document.getElementById('chatClose').onclick = ()=>{ // close pc & dc and go back
    try{ if(pc) pc.close(); }catch(_){} pc=null; dc=null; showContacts(); };
}

/* append chat message to UI and sessionStorage */
function appendChatMessage(text, me){
  const container = document.getElementById('chatHistory');
  const d = document.createElement('div'); d.textContent = (me ? 'Me: ' : 'Peer: ') + text; container.appendChild(d); container.scrollTop = container.scrollHeight;
  if(CURRENT_PEER){
    saveChatMessage(CURRENT_PEER.id, text, me);
  }
}

/* save chat history in sessionStorage (cleared on tab close) */
function saveChatMessage(contactId, text, me){
  const key = 'chat_' + contactId;
  const arr = sessionStorage.getItem(key) ? JSON.parse(sessionStorage.getItem(key)) : [];
  arr.push({ ts: Date.now(), msg: text, me: !!me });
  sessionStorage.setItem(key, JSON.stringify(arr));
}

/* ========= utility to set up initial QR generate/scan flows ========= */
document.getElementById('methodQr').addEventListener('click', ()=>{
  // prepare a local offer when user chooses QR mode
  prepareQrOfferAndShow();
  show('qrGenScreen');
});

/* show QR scanning screen when user needs to scan (for example second peer) */
/* Add a simple button to go to scanner by reusing method screen's choices */
document.getElementById('qrGenBox').addEventListener('click', ()=>{}); // noop

/* Provide a simple path to scanning for the peer: open qrScanScreen manually from method selection */
document.getElementById('methodQr').addEventListener('click', ()=>{/* prepared above */});
document.getElementById('qrScanBack').addEventListener('click', ()=> show('methodScreen'));

/* For the copy/paste page, user can switch to QR generation result if they want */
document.getElementById('offerArea').addEventListener('click', ()=>{ /* allow selection */ });

/* Start scanning from method screen: provide a scan button on method selection by adding handler:
   we will start scanning when the user chooses copy method and clicks "Scan" via the video flow or via explicit QR scan path */
document.getElementById('methodCopy').addEventListener('click', ()=>{/* copy screen shown already */});

/* ========= helper: start app state when loaded ========= */
(function init(){
  // if session password present, load contacts and go to contacts view
  const spw = sessionStorage.getItem('secure_pw');
  if(spw){
    PASSWORD = spw;
    // try load contacts
    const stored = localStorage.getItem(CONTACTS_KEY);
    if(stored){
      decryptWithPassword(stored, spw).then(json=>{
        CONTACTS = JSON.parse(json)||[];
        showContacts();
      }).catch(err=>{
        // invalid session pw: clear
        sessionStorage.removeItem('secure_pw');
        PASSWORD = null;
        show('pwScreen');
      });
    } else {
      show('methodScreen');
    }
  } else {
    show('pwScreen');
  }
})();

/* ========= clean up on close ========= */
window.addEventListener('beforeunload', ()=>{
  // remove password from session (sessionStorage clears on tab close but be explicit)
  sessionStorage.removeItem('secure_pw');
  // clear chat histories
  if(CURRENT_PEER) sessionStorage.removeItem('chat_' + CURRENT_PEER.id);
  // stop camera
  if(videoStream){ videoStream.getTracks().forEach(t=>t.stop()); videoStream=null; }
  try{ if(pc) pc.close(); }catch(_){}
});

/* ========= small helper to prepare offer (used when clicking method-copy -> start offer) ========= */
/* Also allow user to start scanning answer via camera: implement a simple scanAnswer button on copyScreen -> reuse scan flow */
document.getElementById('copyScreen').addEventListener('click', (e)=>{
  // placeholder to keep copy screen active
});

/* Provide a button to go to QR scanner when in method screen - attach on method selection simple flow */
document.getElementById('methodScreen').addEventListener('click', (e)=>{
  // nothing
});

/* Provide 'Scan' operations from copy screen: when user pasted answer they click Accept - handled above. To scan answer using camera, we'll implement a quick helper: */
async function scanForAnswerAndFinish(){
  // opens camera and collects 4 parts in order (same as scanLoop but synchronous one-time)
  scanParts = [];
  await startQrScan();
  // processScannedOfferOrAnswer will handle assembled pieces
}

/* Expose for console/debug */
window._debug = { CONTACTS, PASSWORD };

</script>
</body>
</html>
